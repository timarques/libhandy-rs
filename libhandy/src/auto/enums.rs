// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::StaticType;
use glib::Type;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use gobject_sys;
use handy_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum ArrowsDirection {
    Up,
    Down,
    Left,
    Right,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ArrowsDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ArrowsDirection::{}", match *self {
            ArrowsDirection::Up => "Up",
            ArrowsDirection::Down => "Down",
            ArrowsDirection::Left => "Left",
            ArrowsDirection::Right => "Right",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ArrowsDirection {
    type GlibType = handy_sys::HdyArrowsDirection;

    fn to_glib(&self) -> handy_sys::HdyArrowsDirection {
        match *self {
            ArrowsDirection::Up => handy_sys::HDY_ARROWS_DIRECTION_UP,
            ArrowsDirection::Down => handy_sys::HDY_ARROWS_DIRECTION_DOWN,
            ArrowsDirection::Left => handy_sys::HDY_ARROWS_DIRECTION_LEFT,
            ArrowsDirection::Right => handy_sys::HDY_ARROWS_DIRECTION_RIGHT,
            ArrowsDirection::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyArrowsDirection> for ArrowsDirection {
    fn from_glib(value: handy_sys::HdyArrowsDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ArrowsDirection::Up,
            1 => ArrowsDirection::Down,
            2 => ArrowsDirection::Left,
            3 => ArrowsDirection::Right,
            value => ArrowsDirection::__Unknown(value),
        }
    }
}

impl StaticType for ArrowsDirection {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_arrows_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ArrowsDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ArrowsDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ArrowsDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CenteringPolicy {
    Loose,
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CenteringPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CenteringPolicy::{}", match *self {
            CenteringPolicy::Loose => "Loose",
            CenteringPolicy::Strict => "Strict",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CenteringPolicy {
    type GlibType = handy_sys::HdyCenteringPolicy;

    fn to_glib(&self) -> handy_sys::HdyCenteringPolicy {
        match *self {
            CenteringPolicy::Loose => handy_sys::HDY_CENTERING_POLICY_LOOSE,
            CenteringPolicy::Strict => handy_sys::HDY_CENTERING_POLICY_STRICT,
            CenteringPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyCenteringPolicy> for CenteringPolicy {
    fn from_glib(value: handy_sys::HdyCenteringPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CenteringPolicy::Loose,
            1 => CenteringPolicy::Strict,
            value => CenteringPolicy::__Unknown(value),
        }
    }
}

impl StaticType for CenteringPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_centering_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CenteringPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CenteringPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CenteringPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Fold {
    Unfolded,
    Folded,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Fold {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Fold::{}", match *self {
            Fold::Unfolded => "Unfolded",
            Fold::Folded => "Folded",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Fold {
    type GlibType = handy_sys::HdyFold;

    fn to_glib(&self) -> handy_sys::HdyFold {
        match *self {
            Fold::Unfolded => handy_sys::HDY_FOLD_UNFOLDED,
            Fold::Folded => handy_sys::HDY_FOLD_FOLDED,
            Fold::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyFold> for Fold {
    fn from_glib(value: handy_sys::HdyFold) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Fold::Unfolded,
            1 => Fold::Folded,
            value => Fold::__Unknown(value),
        }
    }
}

impl StaticType for Fold {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_fold_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Fold {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Fold {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Fold {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum LeafletChildTransitionType {
    None,
    Crossfade,
    Slide,
    Over,
    Under,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LeafletChildTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "LeafletChildTransitionType::{}", match *self {
            LeafletChildTransitionType::None => "None",
            LeafletChildTransitionType::Crossfade => "Crossfade",
            LeafletChildTransitionType::Slide => "Slide",
            LeafletChildTransitionType::Over => "Over",
            LeafletChildTransitionType::Under => "Under",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for LeafletChildTransitionType {
    type GlibType = handy_sys::HdyLeafletChildTransitionType;

    fn to_glib(&self) -> handy_sys::HdyLeafletChildTransitionType {
        match *self {
            LeafletChildTransitionType::None => handy_sys::HDY_LEAFLET_CHILD_TRANSITION_TYPE_NONE,
            LeafletChildTransitionType::Crossfade => handy_sys::HDY_LEAFLET_CHILD_TRANSITION_TYPE_CROSSFADE,
            LeafletChildTransitionType::Slide => handy_sys::HDY_LEAFLET_CHILD_TRANSITION_TYPE_SLIDE,
            LeafletChildTransitionType::Over => handy_sys::HDY_LEAFLET_CHILD_TRANSITION_TYPE_OVER,
            LeafletChildTransitionType::Under => handy_sys::HDY_LEAFLET_CHILD_TRANSITION_TYPE_UNDER,
            LeafletChildTransitionType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyLeafletChildTransitionType> for LeafletChildTransitionType {
    fn from_glib(value: handy_sys::HdyLeafletChildTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LeafletChildTransitionType::None,
            1 => LeafletChildTransitionType::Crossfade,
            2 => LeafletChildTransitionType::Slide,
            3 => LeafletChildTransitionType::Over,
            4 => LeafletChildTransitionType::Under,
            value => LeafletChildTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for LeafletChildTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_leaflet_child_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LeafletChildTransitionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LeafletChildTransitionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LeafletChildTransitionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum LeafletModeTransitionType {
    None,
    Slide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LeafletModeTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "LeafletModeTransitionType::{}", match *self {
            LeafletModeTransitionType::None => "None",
            LeafletModeTransitionType::Slide => "Slide",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for LeafletModeTransitionType {
    type GlibType = handy_sys::HdyLeafletModeTransitionType;

    fn to_glib(&self) -> handy_sys::HdyLeafletModeTransitionType {
        match *self {
            LeafletModeTransitionType::None => handy_sys::HDY_LEAFLET_MODE_TRANSITION_TYPE_NONE,
            LeafletModeTransitionType::Slide => handy_sys::HDY_LEAFLET_MODE_TRANSITION_TYPE_SLIDE,
            LeafletModeTransitionType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyLeafletModeTransitionType> for LeafletModeTransitionType {
    fn from_glib(value: handy_sys::HdyLeafletModeTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LeafletModeTransitionType::None,
            1 => LeafletModeTransitionType::Slide,
            value => LeafletModeTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for LeafletModeTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_leaflet_mode_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LeafletModeTransitionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LeafletModeTransitionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LeafletModeTransitionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum SqueezerTransitionType {
    None,
    Crossfade,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SqueezerTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SqueezerTransitionType::{}", match *self {
            SqueezerTransitionType::None => "None",
            SqueezerTransitionType::Crossfade => "Crossfade",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SqueezerTransitionType {
    type GlibType = handy_sys::HdySqueezerTransitionType;

    fn to_glib(&self) -> handy_sys::HdySqueezerTransitionType {
        match *self {
            SqueezerTransitionType::None => handy_sys::HDY_SQUEEZER_TRANSITION_TYPE_NONE,
            SqueezerTransitionType::Crossfade => handy_sys::HDY_SQUEEZER_TRANSITION_TYPE_CROSSFADE,
            SqueezerTransitionType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdySqueezerTransitionType> for SqueezerTransitionType {
    fn from_glib(value: handy_sys::HdySqueezerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SqueezerTransitionType::None,
            1 => SqueezerTransitionType::Crossfade,
            value => SqueezerTransitionType::__Unknown(value),
        }
    }
}

impl StaticType for SqueezerTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_squeezer_transition_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SqueezerTransitionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SqueezerTransitionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SqueezerTransitionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum ViewSwitcherPolicy {
    Auto,
    Narrow,
    Wide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ViewSwitcherPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ViewSwitcherPolicy::{}", match *self {
            ViewSwitcherPolicy::Auto => "Auto",
            ViewSwitcherPolicy::Narrow => "Narrow",
            ViewSwitcherPolicy::Wide => "Wide",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ViewSwitcherPolicy {
    type GlibType = handy_sys::HdyViewSwitcherPolicy;

    fn to_glib(&self) -> handy_sys::HdyViewSwitcherPolicy {
        match *self {
            ViewSwitcherPolicy::Auto => handy_sys::HDY_VIEW_SWITCHER_POLICY_AUTO,
            ViewSwitcherPolicy::Narrow => handy_sys::HDY_VIEW_SWITCHER_POLICY_NARROW,
            ViewSwitcherPolicy::Wide => handy_sys::HDY_VIEW_SWITCHER_POLICY_WIDE,
            ViewSwitcherPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<handy_sys::HdyViewSwitcherPolicy> for ViewSwitcherPolicy {
    fn from_glib(value: handy_sys::HdyViewSwitcherPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ViewSwitcherPolicy::Auto,
            1 => ViewSwitcherPolicy::Narrow,
            2 => ViewSwitcherPolicy::Wide,
            value => ViewSwitcherPolicy::__Unknown(value),
        }
    }
}

impl StaticType for ViewSwitcherPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(handy_sys::hdy_view_switcher_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ViewSwitcherPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ViewSwitcherPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ViewSwitcherPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

